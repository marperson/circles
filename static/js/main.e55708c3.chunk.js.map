{"version":3,"sources":["gamelib/ImagePreloader.ts","gamelib/GameCanvas.tsx","gamelib/behaviors/DefaultSprite.ts","gamelib/types/Point.ts","gamelib/types/Sprite.ts","gamelib/types/Rectangle.ts","gamelib/Scene.ts","gamelib/behaviors/RotatedImageBehavior.ts","sample/BouncingBall.ts","App.js","serviceWorker.js","theme.js","index.js"],"names":["ImagePreloader","imageCache","Map","loadsCompleted","nLoads","loadCallback","callback","this","key","image","get","Error","path","Image","src","onload","set","GameCanvas","props","debug","keysPressed","imagePreloader","state","_scene","canvasRef","React","createRef","preloadImagesKeyPathMap","forEach","preLoadImage","imagesLoaded","transitionScene","newScene","that","addBehavior","handleKill","scene","registerCallback","handleImagesLoaded","canvas","current","ctx","getContext","size","width","height","document","addEventListener","event","delete","e","rect","getBoundingClientRect","handleMouseClick","clientX","left","clientY","top","touch","targetTouches","lastTime","resizeCanvas","init","requestAnimationFrame","loop","time","timeSinceLastAnimation","window","innerWidth","innerHeight","value","handleKeyPressed","save","paintBackground","paint","x","y","updateModel","restore","setState","fillStyle","fillRect","timeSinceLastUpdate","Fragment","Typography","variant","gutterBottom","CircularProgress","id","ref","console","log","constructor","name","Component","DefaultSprite","position","isAlive","speed","angle","acceleration","canCollide","isFixedPosition","behaviors","behavior","push","location","b","otherSprite","handleCollision","pointAsInt","point","Math","round","xySpeed","sprite","cos","sin","union","rect1","rect2","tx2","ty2","rx2","ry2","tx1","ty1","rx1","ry1","intersects","tw","th","rw","rh","tx","ty","rx","ry","remove","array","index","indexOf","splice","Scene","gameCanvas","modelSize","viewPort","collisionListeners","sprites","wrapAround","sceneSpeed","count","totalTime","filter","s","pointInRect","priorPosition","handleMovement","dx","tempArray","slice","length","pop","oldRect","pointSpeed","newX","newY","wrapped","newRect","_handleCollision","sign","removeSprite","collisionSprite","i","displayedSprites","pos","fillText","addSprite","RotatedImageBehavior","drawImage","createWall","isVertical","PI","random","BouncingBall","map","getImageFromCache","radius","getSpritesAtPoint","ball","sz","useStyles","makeStyles","theme","root","flexGrow","infoButton","marginRight","spacing","controlButton","score","title","App","useRef","useState","classes","AppBar","style","background","boxShadow","Toolbar","IconButton","edge","className","color","aria-label","Info","onClick","stopPropagation","Pause","Refresh","Boolean","hostname","match","createMuiTheme","overrides","MuiCssBaseline","body","margin","ReactDOM","render","ThemeProvider","CssBaseline","querySelector","navigator","serviceWorker","ready","then","registration","unregister","catch","error","message"],"mappings":"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","file":"static/js/main.e55708c3.chunk.js","sourcesContent":["export class ImagePreloader{\n    imageCache: Map<string,HTMLImageElement> = new Map();\n    loadsCompleted:number =0;\n    nLoads:number = 0;\n\n    private loadCallback?:() => void;\n\n    registerCallback(callback:() => void  ){\n        if(this.loadsCompleted === this.nLoads)\n            callback();\n        this.loadCallback = callback;\n    }\n    \n    getImageFromCache(key:string):HTMLImageElement{\n        const image = this.imageCache.get(key);\n        this.nLoads++;\n        if(!image)\n            throw Error(\"unable to load image: \" + key);\n        return image;\n    }\n    \n    preLoadImage(key:string, path:string):void{\n        const image = new Image();\n        this.nLoads++;\n        image.src = path;\n    \n        image.onload = () => { \n\n            this.imageCache.set(key, image);\n            if(++this.loadsCompleted === this.nLoads && this.loadCallback){\n                this.loadCallback();\n            }\n        };\n    }\n\n}\n\n//export var __IMAGEPRELOADER__:ImagePreloader = new ImagePreloader();\n","\nimport React from 'react';\n\nimport './GameCanvas.css';\nimport Scene from './Scene';\nimport { ImagePreloader } from './ImagePreloader';\nimport { Typography, CircularProgress } from '@material-ui/core';\ninterface IState{\n    imagesLoaded:false\n}\nexport abstract class GameCanvas extends React.Component {\n\n    debug: boolean = false;\n    keysPressed: Map<string, boolean> = new Map();\n    imagePreloader:ImagePreloader;\n    state:IState;\n    private _scene?: Scene;\n\n    private canvasRef = React.createRef<HTMLCanvasElement>();\n\n    constructor(props:any){\n        super(props);\n        this.imagePreloader = new ImagePreloader();\n        if(this.preloadImagesKeyPathMap){\n            this.preloadImagesKeyPathMap().forEach( (path, key) => this.imagePreloader.preLoadImage(key,path) );\n        }\n        this.state = { imagesLoaded:false};\n    }\n\n    transition(transitionScene: Scene, newScene: Scene) {\n        const that = this;\n        transitionScene.addBehavior({\n            handleKill() {\n                that.scene = newScene;\n            }\n        });\n        if (this.scene !== transitionScene)\n            this.scene = transitionScene;\n    }\n\n    set scene(scene: Scene) {\n        if (this.debug)\n            console.log(`SetScene: ${scene.constructor.name}`);\n        scene.debug = this.debug;\n        const canvas = this.canvasRef.current;\n        scene.size = {width:canvas!.width, height:canvas!.height};\n        this._scene = scene;\n    }\n    get scene(): Scene {\n        return this._scene!;\n    }\n\n    \n    componentDidMount() {    \n        this.imagePreloader.registerCallback( ()=>{  this.handleImagesLoaded()});\n    }    \n    \n    handleImagesLoaded(){\n        const canvas = this.canvasRef.current!;\n        const ctx = canvas.getContext('2d')!;\n        const that = this;\n        let size = {width:canvas.width, height: canvas.height};\n\n        document.addEventListener('keydown', (event) => {\n            that.keysPressed.set(event.key, true);\n        });\n        document.addEventListener('keyup', (event) => {\n            that.keysPressed.delete(event.key);\n        });\n\n        canvas.addEventListener('mousedown', function (e) {\n            const rect = canvas.getBoundingClientRect();\n            that.scene.handleMouseClick(e.clientX - rect.left, e.clientY - rect.top)\n        });\n        document.addEventListener(\"touchmove\", function (e) {\n            const rect = canvas.getBoundingClientRect();\n            const touch = e.targetTouches[0];\n            that.scene.handleMouseClick(touch.clientX - rect.left, touch.clientY - rect.top)\n        }, false);\n\n        let lastTime = 0;\n        this.resizeCanvas();\n        this.init();\n        \n        function loop(time: number) {\n            let timeSinceLastAnimation = (!lastTime) ? 0: time - lastTime;\n            lastTime = time;\n            if(timeSinceLastAnimation > 100){\n                //assume animation thread was paused due to moving off window/browser\n                timeSinceLastAnimation = 0;\n            }\n            if (size.width !== window.innerWidth || size.height !== window.innerHeight) {\n                that.resizeCanvas();\n            }\n\n            that.keysPressed.forEach((value, key) => that.scene.handleKeyPressed(key));\n\n            ctx.save(); //Freeze redraw\n\n            that.paintBackground(ctx);\n            that.scene.paint({x:0,y:0}, ctx, timeSinceLastAnimation);\n            that.scene.updateModel(timeSinceLastAnimation);\n\n            ctx.restore();//now do redraw\n\n            requestAnimationFrame(loop);\n        }\n        requestAnimationFrame(loop);\n        this.setState({imagesLoaded:true})\n    }\n\n    // If window size is changed this is called to resize the canvas\n    // It is not called via the resize event as that can fire to often an\n    // debounce makes it feel sluggish so is called from main loop.\n    resizeCanvas() {\n        const canvas = this.canvasRef.current!;\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n        const size = {width:canvas.width, height:canvas.height};\n        if(this.scene)\n            this.scene.size = size;\n    }\n\n    protected paintBackground(ctx: CanvasRenderingContext2D) {\n        ctx.fillStyle = 'white';\n        ctx.fillRect(0, 0, this.scene.size.width, this.scene.size.height);\n    }\n\n    protected updateModel(timeSinceLastUpdate: number) {\n        this.scene.updateModel(timeSinceLastUpdate);\n    }\n\n    protected preloadImagesKeyPathMap?():Map<string,string>;\n\n    protected abstract init():void;\n\n    render() {\n        return (\n            <React.Fragment>\n                {!this.state.imagesLoaded &&\n                <React.Fragment>\n                    <Typography variant=\"h2\" gutterBottom>\n                    Loading images...\n                    </Typography>\n                    <CircularProgress />\n                    </React.Fragment>        \n                }\n            <canvas id='Canvas' ref={this.canvasRef} />\n            </React.Fragment>\n        );\n    }\n}\n","import { Point } from \"../types/Point\";\nimport { Sprite } from \"../types/Sprite\";\nimport { Size } from \"../types/Size\";\nimport { Behavior } from \"../types/Behavior\";\n\nexport class DefaultSprite implements Sprite{\n    position:Point;\n    size:Size;\n    isAlive:boolean = true;\n\t\n    speed:number = 0.0;\n    angle:number = 0.0;\n    acceleration:number = 0.0;\n\tcanCollide:boolean = false;\n\tisFixedPosition:boolean = false;\n\t\n\tprivate behaviors:Behavior[] = [];\n\t\n\tconstructor(position:Point={x:0.0,y:0.0}, size:Size={width:0.0, height:0.0}){\n        this.position = position;\n        this.size = size;\n\t}\n\t\n\taddBehavior(behavior:Behavior){\n        if(behavior.init) behavior.init(this);\n        this.behaviors.push(behavior);\n    }\n    \n    paint(location:Point, ctx: CanvasRenderingContext2D, timeSinceLastAnimation: number) {\n        this.behaviors.forEach( (b) =>  b.paint?.(this, location, ctx, timeSinceLastAnimation));\n    }\n    updateModel(timeSinceLastUpdate: number) {\n        this.behaviors.forEach( (b) =>  b.updateModel?.(this, timeSinceLastUpdate));\n    }\n    \n    handleKill():void{\n        this.behaviors.forEach( (b) =>  b.handleKill?.(this));\n    }\n    \n    handleCollision?(otherSprite:Sprite):void{\n        this.behaviors.forEach( (b) =>  b.handleCollision?.(this, otherSprite));\n    }\n}","\nexport interface Point{\n    x:number;\n    y:number;\n}\n\nexport function pointAsInt(point:Point): Point{\n    return {x:Math.round(point.x), y:Math.round(point.y)};\n}","import { Point } from \"./Point\";\nimport { Size } from \"./Size\";\n\nexport interface Sprite{\n    position:Point;\n    size:Size;\n    isAlive:boolean;\n    speed?: number;\n    angle?: number;\n    acceleration?: number;\n    priorPosition?:Point;\n    zOrder?:number\n\n    //optional properties\n\tcanCollide?: boolean;\n\tisFixedPosition?: boolean;\n\t\n    paint(location:Point, ctx: CanvasRenderingContext2D, timeSinceLastAnimation: number): void;\n\n    updateModel?(timeSinceLastUpdate: number):void;\n\t\t\n\thandleKill?():void;\n    \n    handleCollision?(otherSprite:Sprite):void;\n    \n}\n\nexport function xySpeed(sprite:Sprite): Point{\n    if(sprite.speed && sprite.angle)\n        return {x: sprite.speed * Math.cos(sprite.angle), y: sprite.speed * Math.sin(sprite.angle)};\n    else return {x:0,y:0};\n}\n\n\nexport function centerPosition(sprite:Sprite): Point{\n    return {x: sprite.position.x + sprite.size.width/2, y: sprite.position.y + sprite.size.height/2};\n}\n\n","import { Point } from \"./Point\";\nimport { Size } from \"./Size\";\n\nexport interface Rectangle{\n    position:Point;\n    size:Size;\n\n}\n\nexport function union(rect1:Rectangle, rect2:Rectangle):Rectangle{\n    let tx2 = rect1.size.width;\n    let ty2 = rect1.size.height;\n    if ((tx2 | ty2) < 0) {\n        // This rectangle has negative dimensions...\n        // If r has non-negative dimensions then it is the answer.\n        // If r is non-existant (has a negative dimension), then both\n        // are non-existant and we can return any non-existant rectangle\n        // as an answer.  Thus, returning r meets that criterion.\n        // Either way, r is our answer.\n        return rect2;\n    }\n    let rx2 = rect2.size.width;\n    let ry2 = rect2.size.height;\n    if ((rx2 | ry2) < 0) {\n        return rect1;\n    }\n    let tx1 = rect1.position.x;\n    let ty1 = rect1.position.y;\n    tx2 += tx1;\n    ty2 += ty1;\n    const rx1 = rect2.position.x;\n    const ry1 = rect2.position.y;\n    rx2 += rx1;\n    ry2 += ry1;\n    if (tx1 > rx1) tx1 = rx1;\n    if (ty1 > ry1) ty1 = ry1;\n    if (tx2 < rx2) tx2 = rx2;\n    if (ty2 < ry2) ty2 = ry2;\n    tx2 -= tx1;\n    ty2 -= ty1;\n    return { position:{x:tx1, y:ty1},size:{width:tx2, height:ty2}};\n\n}\n\nexport function intersects(rect1:Rectangle, rect2:Rectangle):boolean{\n\n    let tw = rect1.size.width;\n    let th = rect1.size.height;\n    let rw = rect2.size.width;\n    let rh = rect2.size.height;\n    if (rw <= 0 || rh <= 0 || tw <= 0 || th <= 0) {\n        return false;\n    }\n    const tx = rect1.position.x;\n    const ty = rect1.position.y;\n    const rx = rect2.position.x;\n    const ry = rect2.position.y;\n    rw += rx;\n    rh += ry;\n    tw += tx;\n    th += ty;\n    //      overflow || intersect\n    return ((rw < rx || rw > tx) &&\n            (rh < ry || rh > ty) &&\n            (tw < tx || tw > rx) &&\n            (th < ty || th > ry));\n}\n\nexport function pointInRect(point:Point, rect:Rectangle):boolean{\n    return point.x >= rect.position.x && point.x < rect.position.x + rect.size.width\n        && point.y >= rect.position.y && point.y < rect.position.y + rect.size.height;\n}","import { GameCanvas } from \"./GameCanvas\";\nimport { DefaultSprite } from \"./behaviors/DefaultSprite\";\nimport { Point, pointAsInt } from \"./types/Point\";\nimport { Sprite, xySpeed } from \"./types/Sprite\";\nimport { Size } from \"./types/Size\";\nimport { union, Rectangle, intersects, pointInRect } from \"./types/Rectangle\";\n\n\nfunction remove(array:any[], key:any){\n    const index = array.indexOf(key, 0);\n    if (index > -1) {\n        array.splice(index, 1);\n    }\n}\n\nexport default class Scene extends DefaultSprite{\n\n    viewPort:Point = {x:0, y:0};\n    gameCanvas:GameCanvas;\n    debug: boolean = false;\n    private collisionListeners:Sprite[] = [];\n\tprivate sprites:Sprite[] = [];\n\t\n\twrapAround:boolean = false;\n\tsceneSpeed:number = 1.0;\n    modelSize:Size;\n    \n    constructor(gameCanvas:GameCanvas, modelSize:Size={width:0.0, height:0.0}){\n        super();\n        this.gameCanvas = gameCanvas;\n        this.modelSize = modelSize;\n    }\n    handleKeyPressed(key: string): void {\n    }\n\n    handleMouseClick(x:number, y:number){\n    }\n\n\n\tgetSpritesAtPoint(point:Point):Sprite[]{\n\t\treturn this.sprites.filter( (s) => pointInRect(point, s) );\n\t}\n\n\taddSprite(sprite:Sprite) {\n\t\tif(this.debug)\n\t\t\tconsole.log(\"AddSprite: \" + sprite);\n\n\t\t//todo: insert by z-order\n\t\tthis.sprites.push(sprite);\n\t\tsprite.priorPosition = sprite.position;\n\t\tif (sprite.handleCollision)\n\t\t\tthis.collisionListeners.push(sprite);\n\t}\n\n\tremoveSprite(sprite:Sprite) {\n\t\tsprite.handleKill?.();\n        if(this.debug)\n            console.log(\"RemoveSprite: \" + sprite);\n        remove(this.sprites, sprite);\n        remove(this.collisionListeners, sprite);\n\t}\n\n\tpublic resetGame() {\n\t    this.sprites = [];\n\t\tthis.collisionListeners = [];\n\t}\n\n    updateModel(timeSinceLastUpdate: number) {\n\t\tsuper.updateModel(timeSinceLastUpdate);\n        \n        // handle movements and check collision\n\t\tthis.handleMovement(timeSinceLastUpdate);\n\t}\n\n    handleMovement(timeSinceLastUpdate: number) {\n        const dx = timeSinceLastUpdate/1000.0;\n        const tempArray:Sprite[] = this.sprites.slice();\n\t\twhile (tempArray.length) {\n\t\t\tconst sprite:Sprite = tempArray.pop()!;\n\t\t\tif(!sprite.isAlive){\n\t\t\t\t// remove any dead sprites.\n\t\t\t\tthis.removeSprite(sprite);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (sprite.speed) {\n\t\t\t\tconst oldRect = {position:pointAsInt(sprite.position), size:sprite.size};\n\t\t\t\tconst pointSpeed = xySpeed(sprite);\n\t\t\t\tlet newX = sprite.position.x + pointSpeed.x * dx * this.sceneSpeed;\n\t\t\t\tlet newY = sprite.position.y + pointSpeed.y * dx * this.sceneSpeed;\n\n\t\t\t\t// handle wrap around\n\t\t\t\tlet wrapped = false;\n\t\t\t\tif (this.wrapAround) {\n\t\t\t\t\tlet width = this.size.width;\n\t\t\t\t\tlet height = this.size.height;\n\t\t\t\t\tif(this.modelSize.width !==0){\n\t\t\t\t\t\twidth= this.modelSize.width;\n\t\t\t\t\t\theight = this.modelSize.height;\n\t\t\t\t\t}\n\t\t\t\t\t\n\t\t\t\t\tif (newX < 0) {\n\t\t\t\t\t\tnewX = width - sprite.size.width;\n\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t} else if (newX + sprite.size.width > width) {\n\t\t\t\t\t\tnewX = 0;\n\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t}\n\t\t\t\t\tif (newY < 0) {\n\t\t\t\t\t\tnewY = height - sprite.size.height;\n\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t} else if (newY + sprite.size.height > height) {\n\t\t\t\t\t\tnewY = 0;\n\t\t\t\t\t\twrapped = true;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\tsprite.priorPosition = oldRect.position;\n\t\t\t\tsprite.position = {x:newX, y:newY};\n\t\t\t\t// check collisions\n\t\t\t\tlet newRect = {position: pointAsInt(sprite.position), size: sprite.size};\n\t\t\t\tif (!wrapped)\n\t\t\t\t\tnewRect = union(oldRect, newRect);\n\t\t\t\t\n\t\t\t\tif(sprite.canCollide)\n\t\t\t\t\tthis._handleCollision(newRect, sprite);\n\t\t\t\tif (sprite.acceleration) {\n\t\t\t\t\tif (Math.sign(sprite.acceleration\n\t\t\t\t\t\t\t+ sprite.speed) !== Math.sign(sprite\n\t\t\t\t\t\t\t.speed))\n\t\t\t\t\t\tsprite.speed = 0;\n\t\t\t\t\telse\n\t\t\t\t\t\tsprite.speed = sprite.speed + sprite.acceleration;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif(sprite.updateModel)\n\t\t\t\tsprite.updateModel(timeSinceLastUpdate);\n\t\t\tif(!sprite.isAlive)\n\t\t\t\tthis.removeSprite(sprite);\n\t\t}\n\t}\n\n\tprivate _handleCollision( newRect:Rectangle, sprite:Sprite) {\n\t\t//need to make this more sophisticated so it doesn't break out after one collision.\n\t\tlet collisionSprite;\n\t\tif(sprite.handleCollision){\n\t\t\tfor(let i =0; i< this.sprites.length;i++){\n\t\t\t\tconst otherSprite = this.sprites[i];\n\t\t\t\tif (sprite !== otherSprite && otherSprite.canCollide) {\n\t\t\t\t\tif (intersects(newRect, otherSprite)) {\n\t\t\t\t\t\tsprite.handleCollision(otherSprite);\n\t\t\t\t\t\tcollisionSprite = otherSprite;\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tif(!collisionSprite)\n\t\t\tcollisionSprite = sprite;\n\t\t\n\t\tfor(let i =0; i< this.collisionListeners.length;i++){\n\t\t\tconst otherSprite = this.collisionListeners[i];\n\t\t\tif (sprite !== otherSprite) {\n\t\t\t\tif (intersects(newRect, otherSprite)) {\n\t\t\t\t\totherSprite.handleCollision!(sprite);\n\t\t\t\t\tcollisionSprite = otherSprite;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tif (!collisionSprite.isAlive) {\n\t\t\tthis.removeSprite(collisionSprite);\n\t\t}\n\t}\n\tcount =0;\n\ttotalTime =0;\n\tpaint(location:Point, ctx: CanvasRenderingContext2D, timeSinceLastAnimation: number):void {\n        //enable you to embed a scene as a sprite in another scene\n        location = {x: location.x + this.viewPort.x, y:location.y+this.viewPort.y}; \n\t\tsuper.paint(location, ctx, timeSinceLastAnimation);\n\t\tlet displayedSprites =0\n\t\tfor(let sprite of this.sprites){\n\t\t\tif(!sprite.isAlive)\n\t\t\t\tthrow Error(\"No Dead Sprites Should Make it to render step.\\n\" + sprite);\n\t\t\tlet pos = pointAsInt(sprite.position);\n\t\t\t\tif(!sprite.isFixedPosition){\n\t\t\t\t\tpos = {x: pos.x - location.x, y: pos.y - location.y}\n\t\t\t\t}\n\t\t\tif(pos.x > this.size.width || pos.y > this.size.height \n\t\t\t\t|| (sprite.size.width + pos.x < 0)\n\t\t\t\t|| (sprite.size.height + pos.y < 0)){\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tsprite.paint(pos, ctx, timeSinceLastAnimation);\n\t\t\tdisplayedSprites++;\n\t\t}\n\t\tif(this.debug){\n\t\t\tif(++this.count % 300 === 0){\n\t\t\t\tthis.totalTime  = timeSinceLastAnimation;\n\t\t\t\tthis.count =1;\n\t\t\t}else{\n\t\t\t\tthis.totalTime +=timeSinceLastAnimation;\n\t\t\t}\n\t\t\tctx.fillText(`FPS: ${Math.round(1000 / (this.totalTime/ ++this.count))} Alive Sprites: ${this.sprites.length} On Screen Sprites: ${displayedSprites}` , 10, this.size.height -10);\n\t\t}\n\t}\n\n\taddSprites(sprites:Sprite[] ) {\n\t\tsprites.forEach( (s) => this.addSprite(s) )\n\t}\n}","import { Behavior } from \"../types/Behavior\";\nimport { Sprite } from \"../types/Sprite\";\nimport { Point } from \"../types/Point\";\n\n\n\nexport class RotatedImageBehavior implements Behavior{\n    image:HTMLImageElement;\n\n\tconstructor(image:HTMLImageElement) {\n        this.image = image;\n\t}\n    init(sprite:Sprite){\n        sprite.size = {width: this.image.width, height: this.image.height}\n\t}\n    paint(sprite:Sprite, location:Point, ctx: CanvasRenderingContext2D, timeSinceLastAnimation: number):void{\n        \n        ctx.drawImage(this.image, location.x, location.y, sprite.size.width, sprite.size.height);\n\t\t// double angle = getAngle();\n\t\t\n\t\t// AffineTransform affineTransform = new AffineTransform();\n\t\t// affineTransform.rotate(angle, x + getSprite().getWidth() / 2.0, y\n\t\t// \t\t+ getSprite().getHeight() / 2.0);\n\t\t// affineTransform.translate(x, y);\n\n\t\t// g.drawImage(image, affineTransform, null);\n\t}\n\t\n\n\n\n}","import { GameCanvas } from \"../gamelib/GameCanvas\";\nimport { Point } from \"../gamelib/types/Point\";\nimport Scene from \"../gamelib/Scene\";\nimport { Sprite, xySpeed } from \"../gamelib/types/Sprite\";\nimport { Size } from \"../gamelib/types/Size\";\nimport { DefaultSprite } from \"../gamelib/behaviors/DefaultSprite\";\nimport { RotatedImageBehavior } from \"../gamelib/behaviors/RotatedImageBehavior\";\n\n\n\nfunction createWall(position:Point, size:Size, isVertical:boolean):Sprite{\n    const wall = {\n        position,\n        size,\n        isAlive:true,\n        paint: function(location:Point, ctx: CanvasRenderingContext2D, timeSinceLastAnimation: number): void{\n            ctx.fillStyle =  \"red\";\n            ctx.fillRect(position.x, position.y, size.width, size.height);\n        },\n        handleCollision(otherSprite:Sprite):void{\n            const speed = xySpeed(otherSprite);\n            if(isVertical){\n                if(speed.x>0)\n                   otherSprite.position.x = this.position.x - otherSprite.size.width;\n                else\n                    otherSprite.position.x = this.position.x + this.size.width;\n                otherSprite.position.y = otherSprite.priorPosition!.y;\n                otherSprite.angle =  Math.PI - otherSprite.angle! + (Math.random() - .5 )*.2;\n            }else{\n                if(speed.y>0)\n                    otherSprite.position.y = this.position.y - otherSprite.size.height;\n                else\n                    otherSprite.position.y = this.position.y + this.size.height;\n                otherSprite.position.x = otherSprite.priorPosition!.x;\n                otherSprite.angle =  -1.0 * otherSprite.angle! + (Math.random() - .5 )*.2;\n            }\n        }\n    };\n    return wall;\n}\n\nexport class BouncingBall extends  GameCanvas{\n    //add button bar to top of screen as overlay.\n    //add pause button\n    //add restart button.\n    //add about button.\n    //handle resize event\n    //use better/smaller color for wall.\n    //find better and smaller ball image\n\n    preloadImagesKeyPathMap():Map<string,string>{\n        const map = new Map();\n        map.set('ball', \"/circles/assets/ball3.png\");\n        return map;\n    }\n\n\n\tinit():void {\n\t\tconst scene = new Scene(this);\n        this.scene = scene;\n\n        const image = this.imagePreloader.getImageFromCache('ball');\n        const radius = image.width/2;\n        scene.handleMouseClick = function(x:number, y:number){\n            const sprites = scene.getSpritesAtPoint({x,y});\n            if(sprites.length){\n                sprites.filter( (s) => s.canCollide ).forEach( (s) => scene.removeSprite(s) );\n                return;\n            }\n            const ball = new DefaultSprite({x:x-radius,y:y-radius});\n            ball.isAlive = true;\n            ball.speed = Math.random() * 10+100;\n            ball.angle = Math.random() * Math.PI *2;\n            ball.canCollide = true;\n            ball.addBehavior(new RotatedImageBehavior(image));\n            scene.addSprite(ball);\t\n        }\n        scene.debug = true;\n        scene.wrapAround = false;\n        const sz = scene.size;\n        const wallSize = 8;\n        //create walls\n        scene.addSprite( createWall({x:0,y:0},{width:sz.width-wallSize,height:wallSize}, false));\n        scene.addSprite( createWall({x:0,y:sz.height-wallSize},{width:sz.width,height:wallSize}, false));\n        scene.addSprite( createWall({x:0,y:0},{width:wallSize,height:sz.height-wallSize}, true));\n        scene.addSprite( createWall({x:sz.width-wallSize,y:0},{width:wallSize,height:sz.height-wallSize}, true));\n\n\t\t// this.scene.addSprite(Wall.newVerticalWall(size.width/3 *2 ,0,size.height/7 *3,2));\t\n\t\t// this.scene.addSprite(Wall.newVerticalWall(size.width/3 *2 ,size.height/7*4,size.height/7 *3,2));\n\t\t\n\t}\n}","import React, { useRef, useState } from 'react';\n\nimport { makeStyles } from '@material-ui/core/styles';\nimport AppBar from '@material-ui/core/AppBar';\nimport Toolbar from '@material-ui/core/Toolbar';\nimport Typography from '@material-ui/core/Typography';\nimport IconButton from '@material-ui/core/IconButton';\nimport { Pause, Info, Refresh } from '@material-ui/icons';\n\nimport { BouncingBall } from './sample/BouncingBall';\n\n\nconst useStyles = makeStyles((theme) => ({\n  root: {\n    flexGrow: 1,\n  },\n  infoButton: {\n    marginRight: theme.spacing(1),\n  },\n  controlButton: {\n\n  },\n  score: {\n    marginRight: theme.spacing(2),\n  },\n  title: {\n    flexGrow: 1,\n  },\n}));\n\nfunction App() {\n\n  const gameRef = useRef(null);\n  const [score, setScore] = useState(0);\n\n  const classes = useStyles();\n\n  function handleRestart(e) {\n    e.stopPropagation();\n    //canvasRef.current.action(\"restart\"); \n  }\n  function handlePause(e) {\n    e.stopPropagation();\n    //canvasRef.current.action(\"restart\"); \n  }\n  return (\n    <React.Fragment>\n      <AppBar position=\"static\" style={{ background: 'transparent', boxShadow: 'none' }}>\n        <Toolbar>\n          <IconButton edge=\"start\" className={classes.infoButton} color=\"primary\" aria-label=\"menu\">\n            <Info />\n          </IconButton>\n          <Typography variant=\"h6\" color=\"primary\" className={classes.title}>\n            Circles\n          </Typography>\n          <Typography variant=\"h6\" color=\"primary\" className={classes.score}>\n            Score: {score}\n          </Typography>\n          <IconButton edge=\"start\" className={classes.controlButton} onClick={handlePause} color=\"primary\" aria-label=\"menu\">\n            <Pause />\n          </IconButton>\n          <IconButton edge=\"start\" className={classes.controlButton} onClick={handleRestart} color=\"primary\" aria-label=\"menu\">\n            <Refresh />\n          </IconButton>\n        </Toolbar>\n      </AppBar>\n      <BouncingBall></BouncingBall>\n    </React.Fragment>\n  );\n\n}\n\nexport default App;","// This optional code is used to register a service worker.\n// register() is not called by default.\n\n// This lets the app load faster on subsequent visits in production, and gives\n// it offline capabilities. However, it also means that developers (and users)\n// will only see deployed updates on subsequent visits to a page, after all the\n// existing tabs open on the page have been closed, since previously cached\n// resources are updated in the background.\n\n// To learn more about the benefits of this model and instructions on how to\n// opt-in, read https://bit.ly/CRA-PWA\n\nconst isLocalhost = Boolean(\n  window.location.hostname === 'localhost' ||\n    // [::1] is the IPv6 localhost address.\n    window.location.hostname === '[::1]' ||\n    // 127.0.0.0/8 are considered localhost for IPv4.\n    window.location.hostname.match(\n      /^127(?:\\.(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)){3}$/\n    )\n);\n\nexport function register(config) {\n  if (process.env.NODE_ENV === 'production' && 'serviceWorker' in navigator) {\n    // The URL constructor is available in all browsers that support SW.\n    const publicUrl = new URL(process.env.PUBLIC_URL, window.location.href);\n    if (publicUrl.origin !== window.location.origin) {\n      // Our service worker won't work if PUBLIC_URL is on a different origin\n      // from what our page is served on. This might happen if a CDN is used to\n      // serve assets; see https://github.com/facebook/create-react-app/issues/2374\n      return;\n    }\n\n    window.addEventListener('load', () => {\n      const swUrl = `${process.env.PUBLIC_URL}/service-worker.js`;\n\n      if (isLocalhost) {\n        // This is running on localhost. Let's check if a service worker still exists or not.\n        checkValidServiceWorker(swUrl, config);\n\n        // Add some additional logging to localhost, pointing developers to the\n        // service worker/PWA documentation.\n        navigator.serviceWorker.ready.then(() => {\n          console.log(\n            'This web app is being served cache-first by a service ' +\n              'worker. To learn more, visit https://bit.ly/CRA-PWA'\n          );\n        });\n      } else {\n        // Is not localhost. Just register service worker\n        registerValidSW(swUrl, config);\n      }\n    });\n  }\n}\n\nfunction registerValidSW(swUrl, config) {\n  navigator.serviceWorker\n    .register(swUrl)\n    .then(registration => {\n      registration.onupdatefound = () => {\n        const installingWorker = registration.installing;\n        if (installingWorker == null) {\n          return;\n        }\n        installingWorker.onstatechange = () => {\n          if (installingWorker.state === 'installed') {\n            if (navigator.serviceWorker.controller) {\n              // At this point, the updated precached content has been fetched,\n              // but the previous service worker will still serve the older\n              // content until all client tabs are closed.\n              console.log(\n                'New content is available and will be used when all ' +\n                  'tabs for this page are closed. See https://bit.ly/CRA-PWA.'\n              );\n\n              // Execute callback\n              if (config && config.onUpdate) {\n                config.onUpdate(registration);\n              }\n            } else {\n              // At this point, everything has been precached.\n              // It's the perfect time to display a\n              // \"Content is cached for offline use.\" message.\n              console.log('Content is cached for offline use.');\n\n              // Execute callback\n              if (config && config.onSuccess) {\n                config.onSuccess(registration);\n              }\n            }\n          }\n        };\n      };\n    })\n    .catch(error => {\n      console.error('Error during service worker registration:', error);\n    });\n}\n\nfunction checkValidServiceWorker(swUrl, config) {\n  // Check if the service worker can be found. If it can't reload the page.\n  fetch(swUrl, {\n    headers: { 'Service-Worker': 'script' },\n  })\n    .then(response => {\n      // Ensure service worker exists, and that we really are getting a JS file.\n      const contentType = response.headers.get('content-type');\n      if (\n        response.status === 404 ||\n        (contentType != null && contentType.indexOf('javascript') === -1)\n      ) {\n        // No service worker found. Probably a different app. Reload the page.\n        navigator.serviceWorker.ready.then(registration => {\n          registration.unregister().then(() => {\n            window.location.reload();\n          });\n        });\n      } else {\n        // Service worker found. Proceed as normal.\n        registerValidSW(swUrl, config);\n      }\n    })\n    .catch(() => {\n      console.log(\n        'No internet connection found. App is running in offline mode.'\n      );\n    });\n}\n\nexport function unregister() {\n  if ('serviceWorker' in navigator) {\n    navigator.serviceWorker.ready\n      .then(registration => {\n        registration.unregister();\n      })\n      .catch(error => {\n        console.error(error.message);\n      });\n  }\n}\n","import { createMuiTheme } from '@material-ui/core/styles';\n\n// A custom theme for this app\nconst theme = createMuiTheme({\n    overrides: {\n        MuiCssBaseline: {\n          '@global': {\n            body: {\n                width: '100%',\n                height: '100%',\n                margin: '0',\n            }\n          },\n        },\n      },\n});\n\nexport default theme;","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport CssBaseline from '@material-ui/core/CssBaseline';\nimport { ThemeProvider } from '@material-ui/core/styles';\nimport App from './App';\nimport * as serviceWorker from './serviceWorker';\nimport './index.css';\nimport theme from './theme';\n\nReactDOM.render(\n  <ThemeProvider theme={theme}>\n    {/* CssBaseline kickstart an elegant, consistent, and simple baseline to build upon. */}\n    <CssBaseline />\n    <App />\n  </ThemeProvider>,\n  document.querySelector('#root'),\n);\n\n// If you want your app to work offline and load faster, you can change\n// unregister() to register() below. Note this comes with some pitfalls.\n// Learn more about service workers: https://bit.ly/CRA-PWA\nserviceWorker.unregister();\n"],"sourceRoot":""}